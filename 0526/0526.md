배열의 크기

```c
#define ARR_SIZE 5       // 매크로 상수로 지정

int add(int a, int b);

int main() {
    int arr[ARR_SIZE] = {0}; // 배열 전체를 0으로 초기화

    arr[0] = 5;
    arr[1] = arr[0] + 10;
    arr[2] = add(arr[0], arr[1]); // 함수의 인자로 사용

    printf("정수 2개를 입력 하세요 : ");
    scanf("%d %d", &arr[3], &arr[4]);

    for(int i = 0; i < ARR_SIZE; i++) {
        printf(" %d ", arr[i]);
    }
    printf("\n\n");
}

int add(int a, int b) {
    return a + b;
}
```

2차원 배열

```c
int main() {
    // 2차원 배열
    int arr[3][3] = {
        {1,2,3},
        {4,5,6},
        {7,8,9}
    };

    // int arr[3][3] = {1,2,3,4,5,6,7,8,9}; // 해당 2차원배열은 위와 동일하다.
    
    printf("1행 1열 : %d | ", arr[0][0]);
    printf("1행 2열 : %d | ", arr[0][1]);
    printf("1행 3열 : %d\n ", arr[0][2]);
    printf("2행 1열 : %d | ", arr[1][0]);
    printf("2행 2열 : %d | ", arr[1][1]);
    printf("2행 3열 : %d\n ", arr[1][2]);
    printf("3행 1열 : %d | ", arr[2][0]);
    printf("3행 2열 : %d | ", arr[2][1]);
    printf("3행 3열 : %d | ", arr[2][2]);

	// for문으로 하면 다음과같다.
	for(int i = 0; i < 3; i++) {
        for(int j = 0; j < 3; j++) {
            printf("%d행 %d열 : %d", i+1, j+1, arr[i][j]);
            if(j < 2) printf(" | ");
            if(j == 2) printf("\n");
        }
    }

    // 1행 1열 : 1 | 1행 2열 : 2 | 1행 3열 : 3
    // 2행 1열 : 4 | 2행 2열 : 5 | 2행 3열 : 6
    // 3행 1열 : 7 | 3행 2열 : 8 | 3행 3열 : 9
}
```

# 포인터

포인터가 가질수 있는값은 오직 주소값만 가질수있다.
포인터란 메모리상에 위치한 특정 데이터의 시작주소를 보관하는 변수
포인터 연산자
##### 주소 연산자 ( & ) : 변수의 이름앞에 사용, 해당(변수)주소값을 반환 번지연산자 라고 하기도함
##### 참조 연산자 ( * ) : 포인터의 이름앞에 사용, 포인터가 가리키는 곳(주소)에 저장된 값 반환

```c
int main() {
    // 포인터 선언
    // 데이터형 *변수명 또는 데이터형 변수명*
    // int *ptr 또는 ptr* 이런식
    // 포인터의 크기는 일정
    // 포인터의 크기는 플랫폼에 따라서 결정
    // 32bit : 4byte, 64bit : 8byte

    int *pi;        // int 타입의 포인터 변수 선언
    double *pd;     // 더블 타입의 포인터 변수 선언
    char *pc;       // 캐릭터 타입의 포인터 변수 선언

    // 64비트 운영체제이기때문에 모두 8의 크기를 보여줌
    printf("int형의 포인터 크기 : %d\n", sizeof(pi));
    printf("double형의 포인터 크기 : %d\n", sizeof(pd));
    printf("char형의 포인터 크기 : %d\n", sizeof(pc));
}
```

----

포인터의 초기화
절대로 포인터에 주소를 직접 대입해서는 안됨
###### int * ptr; ptr = 0x123456; << 이런식으로 직접 대입하면안됨
=======
초기화방식은 아래의 두가지가 대표적이다.
int *ptr;
##### ptr = NULL; (권장)

-----------

& 연산자 -> 주소를 반환

```c
int main() {
    int a;
    a = 2;
    printf("%p\n", &a); // 0x7fffffffd9f4 <- 개인마다 틀림
}
```

---

포인터의 시작

```c
int main() {
    int *ptr;    // 포인터 변수 선언
    int a;

    ptr = &a; // a라는 변수의 주소값을 ptr이라는 주소에 위치시킨다.
    printf("포인터 변수 ptr에 들어있는 것(값) : %p\n", ptr);        //포인터 변수 ptr에 들어있는 것(값) : 0x7fffffffd9ec
    printf("포인터 변수 ptr에 들어있는 것(값) : %p\n", &ptr);       //포인터 변수 ptr에 들어있는 것(값) : 0x7fffffffd9f0
    printf("int a변수의 메모리 주소값 : %p\n : ", &a);             //int a변수의 메모리 주소값 : 0x7fffffffd9ec
}
```

위의 예제에서는 &ptr도 본인의 주소를 가지고있고 ptr = &a 를 했기때문에 ptr이 a의 주소를 가리킨다

---

연산자 (역참조 연산자)
주소에 대응하는 데이터를 반환

```c
int main() {
    int *ptr;
    int a = 2;

    ptr = &a;
    
    printf("a의 값 : %d\n", a);
    printf("a의 주소값 : %p\n", &a); // a의 주소 0x7fffffffd9ec

    printf("*ptr의 값 : %d\n", *ptr); // a의 주소에 가지고있는 값을 반환 2
    printf("ptr의 가리키는 주소 : %p\n", ptr); // ptr이 가리키는 주소, 즉 a의 값이 저장되어있는 주소를 반환 0x7fffffffd9ec
}
```

---

포인터도 변수다

```c
int main() {
    int a, b; // 일반 변수 선언
    int *ptr; // 여기에서 int의 의미는 포인터가 가리키는 곳의 데이터 타입

    ptr = &a; // 포인터 ptr 변수에 a의 주소값으로 저장
    *ptr = 2; // 포인터 ptr이 가리키는곳에 데이터를 2로 저장
    ptr = &b; // 포인터 ptr 변수에 b의 주소값으로 변경 저장 (변수니까 변경 가능)
    *ptr = 3; // 포인터 ptr이 가리키는곳에 데이터를 3으로 저장

    printf(" a의 값 : %d\n", a); // 2
    printf(" b의 값 : %d\n", b); // 3
}
```

---

상수 포인터

```c
int main() {
    int a, b;
    const int *ptr;
    
    ptr = &a; // 정상 (포인터가 가리키는 곳은 변경 가능)
    *ptr = 3; // 오류 (const 가 선언되어있기때문에 포인터가 가리키는 곳의 값은 변경 불가)
    ptr = &b; // 정상 (포인터가 가리키는 곳은 변경 가능)
}
```

```c
int main() {
    int a, b;
    int *const ptr = &a; // const로 한것은 반드시 선언과 동시에 초기화 해야함
    
    *ptr = 3; // 정상 (포인터가 가리키는곳의 값을 변경가능)
    ptr = &b; // 오류 (포인터가 가리키는곳은 변경 불가)
}
```
